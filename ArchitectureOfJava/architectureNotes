Compiler v/s Interpreter
• The main aim of theses two are
1. To check errors
2. Convert into machine code
3. Execution / running a program : Compiler does not takes
responsibility of execution , Interpreter is responsible for execution of
code

Compiler
• Compiler will convert program into machine code if they are no error
• Compilation from source code to machine code is done only once
• As translation is done once that’s why compiler doesn't run codes
• Even if there’s one error in the program , it will not compile the full code
must be error free to transform into machine code.
Interpreter
• JavaScript is an interpreter based language
• JS runs inside browser , it cannot run independently
• It translate and runs /executes the code line by line
• Translation is done again and again
• Compiler is faster than interpreter
• In interpreter if there is error in one line the code will still execute
• Interpreter language is easy than compiler language
[ Java is hybrid programming language which uses both interpreter as well as compiler to execute java programs.]
[ Java uses WORA(Write Once Run Anywhere) methodology for program execution]

........................................................................................................................

Java, being a platform-independent programming language, doesn’t work on the one-step compilation. Instead, it involves
a two-step execution, first through an OS-independent compiler; and second, in a virtual machine (JVM) which is
custom-built for every operating system.

The two principal stages are explained below:
Principle 1: Compilation
First, the source ‘.java’ file is passed through the compiler, which then encodes the source code into a
machine-independent encoding, known as Bytecode. The content of each class contained in the source file is stored in a
separate ‘.class’ file. While converting the source code into the bytecode, the compiler follows the following steps:
Step 1: Parse: Reads a set of *.java source files and maps the resulting token sequence into AST
(Abstract Syntax Tree)-Nodes.
Step 2: Enter: Enters symbols for the definitions into the symbol table.
Step 3: Process annotations: If Requested, processes annotations found in the specified compilation units.
Step 4: Attribute: Attributes the Syntax trees. This step includes name resolution, type checking and constant folding.
Step 5: Flow: Performs dataflow analysis on the trees from the previous step. This includes checks for assignments and
reachability.
Step 6: Desugar: Rewrites the AST and translates away some syntactic sugar.
Step 7: Generate: Generates ‘.Class’ files.

Principle 2: Execution
The class files generated by the compiler are independent of the machine or the OS, which allows them to be run on any
system. To run, the main class file (the class that contains the method main) is passed to the JVM and then goes
through three main stages before the final machine code is executed. These stages are:
ClassLoader
Bytecode Verifier
Just-In-Time Compiler
Let us discuss all 3 stages.
Stage 1: Class Loader
The main class is loaded into the memory bypassing its ‘.class’ file to the JVM, through invoking the latter. All the
other classes referenced in the program are loaded through the class loader.A class loader, itself an object, creates
a flat namespace of class bodies that are referenced by a string name. The method definition is provided below
illustration as follows:
[
// loadClass function prototype
Class r = loadClass(String className, boolean resolveIt);
// className: name of the class to be loaded
// resolveIt: flag to decide whether any referenced class should be loaded or not.
]

There are two types of class loaders
primordial
non-primordial

The primordial class loader is embedded into all the JVMs and is the default class loader. A non-primordial class
loader is a user-defined class loader, which can be coded in order to customize the class-loading process.
Non-primordial class loader, if defined, is preferred over the default one, to load classes.

Stage 2: Bytecode Verifier
After the bytecode of a class is loaded by the class loader, it has to be inspected by the bytecode verifier, whose
job is to check that the instructions don’t perform damaging actions. The following are some of the checks carried out:
Variables are initialized before they are used.
Method calls match the types of object references.
Rules for accessing private data and methods are not violated.
Local variable accesses fall within the runtime stack.
The run-time stack does not overflow.
If any of the above checks fail, the verifier doesn’t allow the class to be loaded.

Stage 3: Just-In-Time Compiler
This is the final stage encountered by the java program, and its job is to convert the loaded bytecode into machine
code. When using a JIT compiler, the hardware can execute the native code, as opposed to having the JVM interpret the
same sequence of bytecode repeatedly and incurring the penalty of a relatively lengthy translation process. This can
lead to performance gains in the execution speed unless methods are executed less frequently.
Conclusion: Due to the two-step execution process described above, a java program is independent of the target
operating system. However, because of the same, the execution time is way more than a similar program written in a
compiled platform-dependent program.

........................................................................................................................

How Java is Platform independent?
The meaning of Java platform-independent is that the Java compiled code(byte code) can run on all operating systems. A
program is written in a language that is a human-readable language. It may contain words, phrases, etc which the
machine does not understand. For the source code to be understood by the machine, it needs to be in a language
understood by machines, typically a machine-level language. So, here comes the role of a compiler. The compiler
converts the high-level language (human language) into a format understood by the machines.
Therefore, a compiler is a program that translates the source code for another program from a programming language into
executable code. This executable code may be a sequence of machine instructions that can be executed by the CPU
directly, or it may be an intermediate representation that is interpreted by a virtual machine. This intermediate
representation in Java is the Java Byte Code.

Step-by-Step Execution of Java Program
Whenever a program is written in JAVA, the javac compiles it.
The result of the JAVA compiler is the .class file or the bytecode and not the machine’s native code
(unlike the C compiler).
The bytecode generated is a non-executable code and needs an interpreter to execute on a machine. This interpreter is
the JVM and thus the Bytecode is executed by the JVM.
And finally, the program runs to give the desired output.

Working of Java Program
Execution of Java Program: In the case of C or C++ (languages that are not platform independent), the compiler
generates a .exe file which is OS dependent. When we try to run this .exe file on another OS it does not run, since it
is OS-dependent and hence is not compatible with the other OS.

Why Java is platform-independent but JVM is platform dependent?
In Java, the main point here is that the JVM depends on the operating system – so if you are running Mac OS X you will
have a different JVM than if you are running Windows or some other operating system. This fact can be verified by
trying to download the JVM for your particular machine – when trying to download it, you will be given a list of JVMs
corresponding to different operating systems, and you will obviously pick whichever JVM is targeted for the operating
system that you are running. So we can conclude that JVM is platform-dependent and it is the reason why Java is able to
become “Platform Independent”.

Important Points:
In the case of Java, it is the magic of Bytecode that makes it platform-independent.
This adds to an important feature in the JAVA language termed portability. Every system has its own JVM which gets
installed automatically when the JDK software is installed. For every operating system separate JVM is available which
is capable to read the .class file or byte code.
An important point to be noted is that while JAVA is a platform-independent language, the JVM is platform-dependent.
Different JVM is designed for different OS and byte code is able to run on different OS.
[Note: As JVM is not platform-dependent because of which Java is not considered completely platform-independent.]

........................................................................................................................

JVM Architecture
JVM(Java Virtual Machine) acts as a run-time engine to run Java applications. JVM is the one that actually calls the
main method present in a Java code. JVM is a part of JRE(Java Runtime Environment).
Java applications are called WORA (Write Once Run Anywhere). This means a programmer can develop Java code on one
system and can expect it to run on any other Java-enabled system without any adjustment. This is all possible because
of JVM.
When we compile a .java file, .class files(contains byte-code) with the same class names present in .java file are
generated by the Java compiler. This .class file goes into various steps when we run it. These steps together describe
the whole JVM.

Class Loader Subsystem
It is mainly responsible for three activities.
Loading
Linking
Initialization

Loading: The Class loader reads the “.class” file, generate the corresponding binary data and save it in the method
area. For each “.class” file, JVM stores the following information in the method area.
-> The fully qualified name of the loaded class and its immediate parent class.
-> Whether the “.class” file is related to Class or Interface or Enum.
-> Modifier, Variables and Method information etc.
After loading the “.class” file, JVM creates an object of type Class to represent this file in the heap memory. Please
note that this object is of type Class predefined in java.lang package. These Class object can be used by the
programmer for getting class level information like the name of the class, parent name, methods and variable
information etc. To get this object reference we can use getClass() method of Object class.
[
// A Java program to demonstrate working
// of a Class type object created by JVM
// to represent .class file in memory.
import java.lang.reflect.Field;
import java.lang.reflect.Method;

// Java code to demonstrate use
// of Class object created by JVM
public class Test {
    public static void main(String[] args)
    {
        Student s1 = new Student();

        // Getting hold of Class
        // object created by JVM.
        Class c1 = s1.getClass();

        // Printing type of object using c1.
        System.out.println(c1.getName());

        // getting all methods in an array
        Method m[] = c1.getDeclaredMethods();
        for (Method method : m)
            System.out.println(method.getName());

        // getting all fields in an array
        Field f[] = c1.getDeclaredFields();
        for (Field field : f)
            System.out.println(field.getName());
    }
}

// A sample class whose information
// is fetched above using its Class object.
class Student {
    private String name;
    private int roll_No;

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public int getRoll_no() { return roll_No; }
    public void setRoll_no(int roll_no)
    {
        this.roll_No = roll_no;
    }
}
Output
Student
getName
setName
getRoll_no
setRoll_no
name
roll_No
]
[ Note: For every loaded “.class” file, only one object of the class is created. ]
[
Student s2 = new Student();
// c2 will point to same object where
// c1 is pointing
Class c2 = s2.getClass();
System.out.println(c1==c2); // true
]

Linking: Performs verification, preparation, and (optionally) resolution.
Verification: It ensures the correctness of the .class file i.e. it checks whether this file is properly formatted and
generated by a valid compiler or not. If verification fails, we get run-time exception java.lang.VerifyError. This
activity is done by the component ByteCodeVerifier. Once this activity is completed then the class file is ready for
compilation.
Preparation: JVM allocates memory for class static variables and initializing the memory to default values.
Resolution: It is the process of replacing symbolic references from the type with direct references. It is done by
searching into the method area to locate the referenced entity.
Initialization: In this phase, all static variables are assigned with their values defined in the code and static
block(if any). This is executed from top to bottom in a class and from parent to child in the class hierarchy.
In general, there are three class loaders :

Bootstrap class loader: Every JVM implementation must have a bootstrap class loader, capable of loading trusted
classes. It loads core java API classes present in the “JAVA_HOME/jre/lib” directory. This path is popularly known as
the bootstrap path. It is implemented in native languages like C, C++.

Extension class loader: It is a child of the bootstrap class loader. It loads the classes present in the extensions
directories “JAVA_HOME/jre/lib/ext”(Extension path) or any other directory specified by the java.ext.dirs system
property. It is implemented in java by the sun.misc.Launcher$ExtClassLoader class.

System/Application class loader: It is a child of the extension class loader. It is responsible to load classes from
the application classpath. It internally uses Environment Variable which mapped to java.class.path. It is also
implemented in Java by the sun.misc.Launcher$AppClassLoader class.

[
// Java code to demonstrate Class Loader subsystem
public class Test {
    public static void main(String[] args)
    {
        // String class is loaded by bootstrap loader, and
        // bootstrap loader is not Java object, hence null
        System.out.println(String.class.getClassLoader());

        // Test class is loaded by Application loader
        System.out.println(Test.class.getClassLoader());
    }
}
Output
null
jdk.internal.loader.ClassLoaders$AppClassLoader@8bcc55f
]

[Note: JVM follows the Delegation-Hierarchy principle to load classes. System class loader delegate load request to
extension class loader and extension class loader delegate request to the bootstrap class loader. If a class found in
the boot-strap path, the class is loaded otherwise request again transfers to the extension class loader and then to
the system class loader. At last, if the system class loader fails to load class, then we get run-time exception
java.lang.ClassNotFoundException.]

JVM Memory
Method area: In the method area, all class level information like class name, immediate parent class name, methods and
variables information etc. are stored, including static variables. There is only one method area per JVM, and it is a
shared resource.
Heap area: Information of all objects is stored in the heap area. There is also one Heap Area per JVM. It is also a
shared resource.
Stack area: For every thread, JVM creates one run-time stack which is stored here. Every block of this stack is called
activation record/stack frame which stores methods calls. All local variables of that method are stored in their
corresponding frame. After a thread terminates, its run-time stack will be destroyed by JVM. It is not a shared
resource.
PC Registers: Store address of current execution instruction of a thread. Obviously, each thread has separate PC
Registers.
Native method stacks: For every thread, a separate native stack is created. It stores native method information.
jvm2

Execution Engine
Execution engine executes the “.class” (bytecode). It reads the byte-code line by line, uses data and information
present in various memory area and executes instructions. It can be classified into three parts:
Interpreter: It interprets the bytecode line by line and then executes. The disadvantage here is that when one method
is called multiple times, every time interpretation is required.
Just-In-Time Compiler(JIT) : It is used to increase the efficiency of an interpreter. It compiles the entire bytecode
and changes it to native code so whenever the interpreter sees repeated method calls, JIT provides direct native code
for that part so re-interpretation is not required, thus efficiency is improved.
Garbage Collector: It destroys un-referenced objects. For more on Garbage Collector, refer Garbage Collector.

Java Native Interface (JNI) :
It is an interface that interacts with the Native Method Libraries and provides the native libraries(C, C++) required
for the execution. It enables JVM to call C/C++ libraries and to be called by C/C++ libraries which may be specific to
hardware.

Native Method Libraries :It is a collection of the Native Libraries(C, C++) which are required by the Execution Engine.

........................................................................................................................

Features of JAVA
Some of the features of JAVA are
• Its simple
• It is secure , as it cannot get infected by virus or any malware because of JVM as it has a securer / verifier who
checks the byte code before executing for virus like malware etc. i.e virus doesn't harm the system.
• It is Platform independent hence Portable
• The style of java programming is object oriented I.e , Abstraction ,Inheritance , Encapsulation and Polymorphism.
• Even if there is unavailability of program JVM makes sure to run it without any crashes in it therefore it is very
robust this is achieved by exception handling.
• Java supports Multithreading
• Java is hardware Architectural neutral so, it can run on any hardware,famous architectures like Von-Neumann, ARM,
RISC, CISC or emmbedded.
• It is interpreter language but still gives high performance with the help of JIT compiler.
• It supports Distributed computing which is mostly used  by businesses globally where multiple business are connected
to a single network.
